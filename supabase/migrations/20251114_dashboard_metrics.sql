-- Dashboard Metrics SQL Migration
-- Run this in your Supabase SQL Editor to create the necessary functions

DO $main_block$
BEGIN

-- ========= SCHEMA AND TABLES =========
CREATE SCHEMA IF NOT EXISTS public;

CREATE TABLE IF NOT EXISTS public.products (
    sku TEXT PRIMARY KEY NOT NULL,
    user_id UUID NOT NULL REFERENCES auth.users(id),
    name TEXT NOT NULL,
    cost_price NUMERIC NOT NULL CHECK (cost_price >= 0),
    price NUMERIC NOT NULL CHECK (price >= 0),
    quantity INTEGER NOT NULL DEFAULT 0 CHECK (quantity >= 0),
    low_stock_threshold INTEGER NOT NULL DEFAULT 10 CHECK (low_stock_threshold >= 0),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    expiry_date TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS public.contacts (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id),
    name TEXT NOT NULL,
    phone_number TEXT,
    contact_type TEXT NOT NULL CHECK (contact_type IN ('customer', 'supplier')),
    current_balance NUMERIC NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.transactions (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id UUID NOT NULL REFERENCES auth.users(id),
    "timestamp" TIMESTAMPTZ NOT NULL DEFAULT now(),
    subtotal NUMERIC NOT NULL CHECK (subtotal >= 0),
    discount_percent NUMERIC NOT NULL DEFAULT 0 CHECK (discount_percent >= 0 AND discount_percent <= 100),
    total NUMERIC NOT NULL CHECK (total >= 0),
    contact_id UUID REFERENCES public.contacts(id) ON DELETE SET NULL
);

CREATE TABLE IF NOT EXISTS public.transaction_items (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    transaction_id BIGINT NOT NULL REFERENCES public.transactions(id) ON DELETE CASCADE,
    product_sku TEXT NOT NULL REFERENCES public.products(sku) ON DELETE RESTRICT,
    name TEXT NOT NULL,
    quantity_sold INTEGER NOT NULL CHECK (quantity_sold > 0),
    price_per_item NUMERIC NOT NULL CHECK (price_per_item >= 0)
);

CREATE TABLE IF NOT EXISTS public.ledger_entries (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    contact_id UUID NOT NULL REFERENCES public.contacts(id) ON DELETE CASCADE,
    amount NUMERIC NOT NULL CHECK (amount > 0),
    entry_type TEXT NOT NULL CHECK (entry_type IN ('credit_given', 'payment_received')),
    description TEXT,
    transaction_date TIMESTAMPTZ NOT NULL DEFAULT now()
);


-- ========= ENABLE ROW LEVEL SECURITY (RLS) =========
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transaction_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.contacts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ledger_entries ENABLE ROW LEVEL SECURITY;


-- ========= CREATE RLS POLICIES =========
IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'Users can manage their own products' AND polrelid = 'public.products'::regclass) THEN
    CREATE POLICY "Users can manage their own products" ON public.products
        FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
END IF;

IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'Users can manage their own contacts' AND polrelid = 'public.contacts'::regclass) THEN
    CREATE POLICY "Users can manage their own contacts" ON public.contacts
        FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
END IF;

IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'Users can manage their own transactions' AND polrelid = 'public.transactions'::regclass) THEN
    CREATE POLICY "Users can manage their own transactions" ON public.transactions
        FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
END IF;

IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'Users can manage items in their own transactions' AND polrelid = 'public.transaction_items'::regclass) THEN
    CREATE POLICY "Users can manage items in their own transactions" ON public.transaction_items
        FOR ALL USING ( (SELECT user_id FROM public.transactions WHERE id = transaction_id) = auth.uid() );
END IF;

IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'Users can manage ledger entries for their own contacts' AND polrelid = 'public.ledger_entries'::regclass) THEN
    CREATE POLICY "Users can manage ledger entries for their own contacts" ON public.ledger_entries
        FOR ALL USING ( (SELECT user_id FROM public.contacts WHERE id = contact_id) = auth.uid() );
END IF;


-- ========= AUTOMATION FOR KHATA BALANCE =========
CREATE OR REPLACE FUNCTION public.update_contact_balance()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $func$
BEGIN
    IF NEW.entry_type = 'credit_given' THEN
        UPDATE public.contacts
        SET current_balance = current_balance + NEW.amount
        WHERE id = NEW.contact_id;
    ELSIF NEW.entry_type = 'payment_received' THEN
        UPDATE public.contacts
        SET current_balance = current_balance - NEW.amount
        WHERE id = NEW.contact_id;
    END IF;
    RETURN NEW;
END;
$func$;

IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_ledger_entry_insert') THEN
    CREATE TRIGGER on_ledger_entry_insert
    AFTER INSERT ON public.ledger_entries
    FOR EACH ROW EXECUTE FUNCTION public.update_contact_balance();
END IF;


-- ========= DASHBOARD METRIC FUNCTIONS =========
-- Function to get the count of all low-stock items for the current user
CREATE OR REPLACE FUNCTION get_low_stock_count()
RETURNS integer LANGUAGE sql STABLE SECURITY DEFINER AS $function_body$
    SELECT COUNT(*)::integer
    FROM public.products
    WHERE
      quantity <= low_stock_threshold
      AND auth.uid() = user_id;
$function_body$;

-- Function to get the count of items expiring within the next 7 days
CREATE OR REPLACE FUNCTION get_near_expiry_count()
RETURNS integer LANGUAGE sql STABLE SECURITY DEFINER AS $function_body$
    SELECT COUNT(*)::integer
    FROM public.products
    WHERE
      expiry_date IS NOT NULL
      AND expiry_date BETWEEN now() AND (now() + interval '7 days')
      AND auth.uid() = user_id;
$function_body$;

END;
$main_block$;
